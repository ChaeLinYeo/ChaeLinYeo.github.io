---
title : "[Recommendation system]Basic Recommendation System 구현 II"
data : 2021-03-03 00:15:28 -0400
categories : 프로그래머스인공지능스쿨
use_math: true
---
# ML 기반 추천 엔진: 협업 필터링 기반 추천 엔진
## 추천엔진의 기본구조(전체 추천 페이지 레벨)
1. 입력: 사용자 -> 
2. 개인 행동 정보(클릭, 구매, 소비)와 추천 유닛1,2,3,... 을 가지고 추천 유닛 후보 생성 -> 
3. 추천 유닛 후보 랭킹 -> 
4. 출력: 추천 유닛
<br>
<br>

## 추천엔진의 기본적인 구조(추천 유닛 레벨)
1. 입력: 사용자 혹은 아이템 ->
2. 개인의 선호도 정보, 아이템 정보를 가지고 추천 후보 생성 로직 ->
    - 다양한 알고리즘이 사용됨(대부분 하이브리드)
3. 추천 후보 랭킹/필터링(전에 해당 알고리즘이 반응이 안좋았다면 조정해야하고... 등등)
4. 출력: 추천 아이템들
<br>
<br>

## 협업 필터링 소개
- 다른 사용자들의 정보를 이용해 내 취향을 예측하는 방식
    1. 사용자 기반(user to user)
        - 나와 비슷한 평점 패턴을 보이는 사람들이 높게 평가한 아이템 추천
    2. 아이템 기반(item to item)
        - 평점의 패턴이 비슷한 아이템들을 찾아서 추천
    3. 예측 모델 기반
        - 사용자 기반, 아이템 기반 추천은 유사도를 기반으로 추천 아이템을 결정
        - 예측 모델 기반 방식은 평점을 예측하는 머신러닝 모델을 만듦
- 구현하는 방식
    1. 메모리 기반
        - 코사인 유사도나 피어슨 상관계수 유사도를 이용해 비슷한 사용자 혹은 아이템을 찾음(유사도 계산)
        - 평점을 예측할 때는 가중치를 사용한 평균을 사용
        - 이해하기 쉽고 설명하기 쉽지만 스케일하기 힘듦(평점 데이터의 부족)
    2. 모델 기반
        - 어떻게 예측해야하는지 패턴을 배우는 것.(추천할 아이템 예측)
        - 머신 러닝을 이용해 평점 예측(PCA, SVD, Matrix Factorization, 딥러닝, ...)
            - 딥러닝의 경우 오토인코더로 차원축소
        - 행렬의 차원을 줄여 평점 데이터의 부족 문제 해결
        - 스케일하기 쉽지만 어떻게 동작하는지 설명 힘듦(내부 구조 블랙박스)
<br>
<br>

## 메모리 기반 vs. 모델 기반
- 메모리 기반은 유사도 함수를 기반으로 비슷한 사용자나 아이템을 검색
    - KNN 방식
    - 평점 예측 X, 유사도 기반 추천 O
    - 모델링으로 학습하는게 아님.
- 모델 기반은 비용함수를 기반으로 학습
    - 즉 머신러닝이라 할 수 있다.
        - 넷플릭스 프라이즈에서는 RMSE를 비용함수(지표)로 사용(실제 평점과 예측 평점간의 차이)
    - SVD++에서는 SGD를 사용하여 딥러닝처럼 학습 -> 넷플릭스 프라이즈에서 나왔던 방식!
    - 딥러닝에서는 오토인코더를 사용해 사용자 아이템 행렬의 패턴을 배움
        - 오토인코더: 딥러닝에서 데이터 차원을 축소하는 방식으로 인코딩을 통해 데이터를 압축하고 디코딩을 통해 데이터 복구. 인코딩을 하는 부분이 결국 차원 축소 담당. 큰 행렬을 작은 행렬로 만듦.
<br>
<br>

## 협업 필터링(or 일반적인 추천 엔진) 평가
- 메모리 기반 협업 필터링
    - 평점의 예측 없이 유사도 기반으로 추천할 아이템 결정
        - 따라서 RMSE와 같은 평점 기반 평가 불가
        - 평점을 예측하는게 아님
    - 보통 Top-N(or nDCG)방식으로 평가
        - nDCG는 Top-N과 같은건데 좀더 최적화된 것
        - Top-N은 사용자가 좋아한 아이템을 일부 남겨두었다가 추천 리스트에 포함되어있는지 보는 방식(사용자가 좋아했다는 평가 기록이 있어야함)
        - 추천 순서를 고려해서 가중치를 주고 평가하면 nDCG(normalized Discounted Cumulative Gain). 첫번째로 리턴되는게 나중에 리턴되는 것보다 사용자가 좋아할 가능성 높음. 즉 랭킹을 매겨서 추천하는 것.
    - 모델 기반 협업 필터링
        - 머신러닝 알고리즘들이 사용하는 일반적인 방식(RMSE 등)으로 성능 평가 가능
        - 메모리 기반에서 사용하는 Top-N, nDCG 방식도 사용 가능
    - 온라인 테스트(A/B 테스트)
        - 가장 좋은 방식은 실제 사용자들에게 노출시켜 성능 평가하는 것(A/B 테스트 가능한 인프라 구조, 사용자가 충분해야 함)
<br>
<br>

## SurpriseLib 소개
- 협업 필터링 과 관련한 다양한 기능을 제공하는 라이브러리
    - KNNBasic 객체 이용해 사용자 기반 or 아이템 기반 협업 필터링 구현
    - SVD 혹은 SVDpp 객체를 이용해 모델 기반 협업 필터링
- 협업 필터링 알고리즘의 성능 평가를 위한 방법 제공
<br>
<br>
<br>

# 사용자 기반 협업 필터링
## 사용자의 유사도 측정
- 사용자들을 벡터(아이템에 대한 평점)로 표현
- 지정된 사용자(u)와 다른 나머지 사용자들과의 유사도 측정
    - 공통으로 평점을 준 아이템만 대상으로 사용자들간의 유사도 측정
        - u와 다른 사용자들(u') 대상으로 유사도 측정
    - 이 중 가장 비슷한 K명의 사용자를 선택(Top K), 이 K명의 사용자들이 좋게 평가한 아이템들 중에 사용자 u가 평가하지 않은 아이템이 있으면 추천해야 한다.
    - 이 K명의 사용자들(u') 대상으로 u가 평가하지 않은 아이템을 평가
        - u'가 평가한 아이템 i의 평점에 u와 u'의 유사도를 가중치(weight)로 해서 그 합을 계산
        - 합산한 값이 큰 아이템들을 추천
- 사용자 대 아이템 행렬을 사용자간 유사도 행렬으로 변환(행: 사용자, 열: 아이템)
<br>
<br>

# 아이템 기반 협업 필터링
## 아이템의 유사도 측정
- 주어진 아이템을 기반으로 가장 비슷한 아이템을 찾아서 추천
    - 사용자 대 아이템 행렬을 사용자간 유사도 행렬으로 변환(행: 아이템, 열: 사용자)
    - i가 메인 아이템, j는 비교 대상이 되는 아이템이라고 하면
    - 분자: i, j를 모두 평가한 사용자 u를 대상으로 i와 j간의 유사도를 계산해서 합산
    - 분모: 모든 사용자 u의 아이템 i 평점을 제곱 후 합산하여 루트 계산 * 모든 사용자 u의 아이템 j 평점을 제곱 후 합산하여 루트 계산
    - 최종적으로 i와 유사도가 가장 큰 j를 추천(N개)
<br>
<br>
 
## 요약
- 협업필터링 방식
    - 사용자 기반과 아이템 기반의 유사도를 바탕으로 추천하는 메모리 방식
    - 평점을 예측하여 추천하는 모델 방식
- Surprise 라이브러리를 이용하여 사용자 기반과 아이템 기반 협업 필터링 구현 
- 다음 포스트에서 평점을 예측하여 추천하는 모델방식을 볼 것.