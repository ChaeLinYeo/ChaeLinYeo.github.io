---
title : "[프로그래머스 인공지능 스쿨]Day01:어서와! 자료구조와 알고리즘은 처음이지?(2)"
data : 2020-12-01 10:15:28 -0400
categories : 프로그래머스 인공지능 스쿨
---
## 12. 스택의 응용 - 수식의 후위 표기법(Postfix Notation)
### 중위 표기법과 후위 표기법
- 중위 표기법(infix notation) : 연산자가 피연산자들의 사이에 위치
```
(A+B)*(C+D)
```

- 후위 표기법(postfix notation) : 연산자가 피연산자들의 뒤에 위치
```
AB+CD+*
```

### 중위 표현식 -> 후위 표현식
[중위]A*B+C -> [후위]AB*C+ <br>
[중위]A+B*C -> [후위]ABC*+<br>
[중위]A+B+C -> [후위]AB+C+<br>

### 괄호의 처리
[중위](A+B)*C -> [후위]AB+C*<br>
여는 괄호는 스택에 push<br>
닫는 괄호를 만나면 여는 괄호가 나올 때까지 pop<br>
[중위]A*(B+C) -> [후위]ABC+*<br>
연산자를 만났을 때, 여는 괄호 너머까지 pop하지 않도록<br>
여는 괄호의 우선순위는 가장 낮게 설정<br>

### 예제1
[중위](A+B)*(C+D) -> [후위]AB+CD+*<br>
[중위]A*(B-(C+D)) -> [후위]ABCD+-*<br>

### 알고리즘의 설계
연산자의 우선순위 설정<br>
```python
prec = {
    '*':3, '/':3,
    '+':2, '-':2,
    '(':1
}
```
파이썬의 사전이다~<br>

중위 표현식을 왼쪽부터 한 글짜씩 읽어서 <br>
피연산자이면 그냥 출력<br>
'('이면 스택에 push<br>
')'이면 '('이 나올 때까지 스택에서 pop 출력<br>
연산자이면 스택에서 이보다 높(거나 같)은 우선순위 것들을 pop, 출력<br>
그리고 이 연산자는 스택에 push<br>
스택에 남아 있는 연산자는 모두 pop해서 출력<br>

### 코드의 구현 - 힌트
스택의 맨 위에 있는 연산자와의 우선순위 비교<br>
스택의 peek() 연산 이용<br>
스택에 남아 있는 연산자 모두 pop()하는 순환문<br>
while not opStack.isEmpty():<br>

<br>
<br>

## 13. 스택의 응용 - 후위 표기 수식 계산
### 후위 표기식의 계산
(A+B)*(C+D) -> AB+CD+*<br>
1. A push
2. B push
3. A pop
4. B pop
5. A+B 수행
6. A+B push
7. C push
8. D push
9. D pop
10. C pop
11. C+D 수행
12. C+D push
13. C+D pop
14. A+B pop
15. (A+B)*(C+D) 수행
16. (A+B)*(C+D) push
17. (A+B)*(C+D) return

### 알고리즘의 설계
```
후위 표현식을 왼쪽부터 한 글자씩 읽어서
    피연산자이면 스택에 push
    연산자를 만나면 스택에서 pop -> (1), 또 pop -> (2)
        (2)연산 (1)을 계산, 이 결과를 스택에 push
수식의 끝에 도달하면 스택에서 pop -> 이것이 계산 결과
```

<br>
<br>

## 큐(Queues)
큐(Queue) : 자료(data element)를 보관할 수 있는 (선형) 구조<br>
단, 넣을 때에는 한 쪽 끝에서 밀어 넣어야 하고<br>
-> 인큐(enqueue)연산 <br>
꺼낼 때에는 반대 쪽에서 뽑아 꺼내야 하는 제약이 있음<br>
-> 디큐(dequeue)연산<br>
선입선출(FIFO - First In First Out)특징을 가지는 선형 자료구조<br>
ex)영화관 입장줄<br>

### 큐의 동작
```python
Q = Queue()
Q.enqueue(A)
Q.enqueue(B)
r1 = Q.dequeue()
r2 = Q.dequeue()
```

### 큐의 추상적 자료구조 구현
1. 배열을 이용하여 구현 
- 파이썬 리스트와 메서드들을 이용

2. 연결리스트를 이용하여 구현
- 이전 강의에서 마련한 양방향 연결 리스트를 이용해 구현

- 연산의 정의
    - size() : 현재 큐에 들어 있는 데이터 원소의 수를 구함
    - isEmpty() : 현재 큐가 비어 있는지를 판단
    - enqueue(x) : 데이터 원소 x를 큐에 추가
    - dequeue() : 큐의 맨 앞에 저장된 데이터 원소를 제거(또한, 반환)
    - peek() : 큐의 맨 앞에 저장된 데이터 원소를 반환(제거하지 않음)

### 배열로 구현한 큐의 연산 복잡도

|연산|복잡도|
|---|---|
|size()|O(1)|
|isEmpty()|O(1)|
|enqueue()|O(1)|
|dequeue()|O(n)|
|peek()|O(1)|

```python
from pythonds.basic.queue import Queue
```
위를 이용해 파이썬에서 제공하는 큐 라이브러리를 쓸 수 있다.<br>

<br>
<br>

## 15. 환형 큐(circular queues)
### 큐의 활용
- 자료를 생성한는 작업과 그 자료를 이용하는 작업이 비동기적으로(asynchronously)일어나는 경우
- 자료를 생성하는 작업이 여러 곳에서 일어나는 경우
- 자료를 이용하는 작업이 여러 곳에서 일어나는 경우
- 자료를 생성하는 작업과 그 자료를 이용하는 작업이 양쪽 다 여러 곳에서 일어나는 경우
- 자료를 처리하여 새로운 자료를 생성하고, 나중에 그 자료를 또 처리해야 하는 작업의 경우

### 환형 큐(circular queue)
정해진 개수의 저장 공간을 빙 돌려가며 이용<br>
```python
Q.enqueue(A)
Q.enqueue(B)
Q.enqueue(C)
r1 = Q.dequeue()
Q.enqueue(D)
r2 = Q.dequeue()
```
큐가 가득 차면?<br>
->더이상 원소를 넣을 수 없음(큐 길이를 기억하고 있어야)<br>

### 환형 큐의 추상적 자료구조 구현
- 연산의 정의
    - size() : 현재 큐에 들어 있는 데이터 원소의 수를 구함
    - isEmpty() : 현재 큐가 비어 있는지를 판단
    - isFull() : 큐에 데이터 원소가 꽉 차 있는지를 판단
    - enqueue(x) : 데이터 원소 x를 큐에 추가
    - dequeue() : 큐의 맨 앞에 저장된 데이터 원소를 제거(또한, 반환)
    - peek() : 큐의 맨 앞에 저장된 데이터 원소를 반환(제거하지 않음)

### 배열로 구현한 환형 큐
정해진 길이 n의 리스트를 확보해 두고<br>
front와 rear를 적절히 계산하여 배열을 환형으로 재활용<br>

<br>
<br>

## 16. 우선순위 큐
우선순위 큐(Priority Queue) : 큐가 FIFO(First In First Out) 방식을 따르지 않고 원소들의 우선순위에 따라 큐에서 빠져나오는 방식<br>

|Enqueue|Dequeue|
|---|---|
|6|2|
|7|3|
|3|6|
|2|7|

### 우선순위 큐의 활용
- 운영체제의 CPU 스케줄러

### 우선순위 큐의 구현
- 서로 다른 두 가지 방식이 가능할 듯 : 
1. Enqueue할 때 우선순위 순서를 유지하도록
2. Dequeue할 때 우선순위 높은 것을 선택
-> 어느 것이 더 유리할까?<br>

- 서로 다른 두 가지 재료를 이용할 수 있음:
1. 선형 배열 이용
2. 연결 리스트 이용
-> 어느 것이 더 유리할까?<br>

<br>
<br>

## 17. 트리(Tree)
트리 : 정점(node)와 간선(edge)을 이용하여 데이터의 배치 형태를 추상화한 자료 구조<br>
가장 최상단 노드가 루트 노드<br>
가장 아래의 자식이 없는 노드가 leaf 노드<br>
루트도 leaf도 아닌 노드는 internal node<br>
부모노드와 자식 노드<br>
부모의 부모(의 부모의...) - 조상(ancestor)<br>
자식의 자식(의 자식의...) - 후손(descendant)<br>
노드의 수준(Level)<br>
- root의 level은 0
- 한 노드씩 내려오며 level++
부분트리(서브트리-Subtree)<br>
노드의 차수(Degree) = 자식(서브트리)의 수<br>

### 이진트리(Binary Tree)
모든 노드의 차수가 2 이하인 트리<br>
재귀적으로 정의할 수 있음 : 루트 노드 + 왼쪽 서브트리 + 오른쪽 서브트리(단, 이 때 왼쪽과 오른쪽 서브트리 또한 이진 트리)<br>

### 포화 이진 트리(Full Binary Tree)
모든 레벨에서 노드들이 모두 채워져 있는 이진 트리<br>
(높이가 k이고 노드의 개수가 2^k-1인 이진 트리)<br>

### 완전 이진 트리(Complete Binary Tree)
높이 k인 완전 이진 트리<br>
레벨 k-2까지는 모든 노드가 2개의 자식을 가진 포화 이진 트리<br>
레벨 k-1에서는 왼쪽부터 노드가 순차적으로 채워져 있는 이진 트리<br>

<br>
<br>

## 18. 이진 트리(Binary Trees)
### 이진 트리의 추상적 자료구조
- 연산의 정의
    - size() - 현재 트리에 포함되어 있는 노드의 수를 구함. 재귀적인 방법으로 쉽게 구할 수 있음.
        - 전체 이진 트리의 size() = left subtree의 size() + right subtree의 size() + 1(자기 자신)
    - depth() - 현재 트리의 깊이(또는 높이; height)를 구함. 재귀적인 방법으로 쉽게 구할 수 있음!
        - 전체 이진 트리의 depth() = left subtree의 depth()와 right subtree의 depth()중 더 큰 것 + 1(루트개수~)
    - 순회(traversal)

### 이진 트리의 순회(Traversal)
- 깊이 우선 순회(depth first traversal)
    - 중위 순회(in-order traversal)
    - 전위 순회(pre-order traversal)
    - 후위 순회(post-order traversal)
- 넓이 우선 순회(breadth first traversal)

### 중위 순회(in-order traversal)
순회의 순서 : <br>
1. Left subtree
2. 자기 자신
3. Right subtree

### 전위 순회(pre-order traversal)
순회의 순서 : <br>
1. 자기 자신
2. Left subtree
3. Right subtree

### 후위 순회(post-order traversal)
순회의 순서 : <br>
1. Left subtree
2. Right subtree
3. 자기 자신

<br>
<br>

## 19. 이진 트리 - 넓이 우선 순회(breath first traversal)
### 넓이 우선 순회(Breath First Traversal)
- 원칙
    - 수준(level)이 낮은 노드를 우선으로 방문
    - 같은 수준의 노드들 사이에는,
        - 부모 노드의 방문 순서에 따라 방문
        - 왼쪽 자식 노드를 오른쪽 자식보다 먼저 방문
- 재귀적(recursive)방법이 적합한가?

