---
title : "[프로그래머스 인공지능 스쿨]Day03:파이썬을 무기로, 코딩테스트 광탈을 면하자! (2)"
data : 2020-12-04 00:15:28 -0400
categories : 프로그래머스 인공지능 스쿨
---
## Step 5-1: 힙(Heap) 대표 문제 풀이: 더 맵게
### 문제 설명
매운 것을 좋아하는 Leo는 모든 음식의 스코빌 지수를 K 이상으로 만들고 싶습니다. 모든 음식의 스코빌 지수를 K 이상으로 만들기 위해 Leo는 스코빌 지수가 가장 낮은 두 개의 음식을 아래와 같이 특별한 방법으로 섞어 새로운 음식을 만듭니다.<br>
```
섞은 음식의 스코빌 지수 = 가장 맵지 않은 음식의 스코빌 지수 + (두 번째로 맵지 않은 음식의 스코빌 지수 * 2)
```
Leo는 모든 음식의 스코빌 지수가 K 이상이 될 때까지 반복하여 섞습니다.<br>
Leo가 가진 음식의 스코빌 지수를 담은 배열 scoville과 원하는 스코빌 지수 K가 주어질 때, 모든 음식의 스코빌 지수를 K 이상으로 만들기 위해 섞어야 하는 최소 횟수를 return 하도록 solution 함수를 작성해주세요.<br>

### 제한 사항
- scoville의 길이는 1 이상 1,000,000 이하입니다.
- K는 0 이상 1,000,000,000 이하입니다.
- scoville의 원소는 각각 0 이상 1,000,000 이하입니다.
- 모든 음식의 스코빌 지수를 K 이상으로 만들 수 없는 경우에는 -1을 return 합니다.

### 문제의 해결 - 예제
```
1   2   3   9   10  12  k=7
```
만약 오름차순으로 정렬되어 있지 않다면 정렬해야 한다.<br>
```
3   9   10  12  k=7
1+(2*2)=5
->
3   5   9   10  12
```
```
9   10  12
3+(5*2)=13
->
9   10  12  13
```
9는 k=7보다 크기 때문에 여기까지 하고 끝낸다.

### 알고리즘의 복잡도
- 최악의 경우 : 
    - 수가 하나 남을 때까지 섞어야 하는 경우(n-1회)
- 각 단계("섞는 일")에서 요구되는 계산량:
    - 정렬된 리스트에 순서 맞추어 원소 삽입
    - O(n)
- 전체 문제 풀이의 복잡도:
    - n번의 단계를 거치는데 각 단계에서 n에 비례하는 계산을 하기 때문에
    - O(n^2)
    - 지나치게 높다.

### 보다 나은 방법
- 최소/최대 원소를 빠르게 꺼낼 수 있으면 좋겠는데!
- 힙(heap)
    - max heap
    - min heap

### 힙(Heaps)
- 성질 : 최대/최소 원소를 빠르게 찾을 수 있음. 상수 시간에 원소들 중 가장 큰 것, 가장 작은 것을 찾을 수 있음! 
- 연산
    - 힙 구성(heapify) : O(NlogN), 빈 힙에 n개의 원소를 차례로 삽입하기 때문에. 하나의 원소를 삽입하는데 logN만큼 걸리므로 N개의 원소를 다 삽입하면 NlogN
    - 삽입(insert) : O(logN)
    - 삭제(remove) : O(logN)

### 힙의 구현
- 완전 이진 트리(complete binary tree)
    - 배열을 이용해서 구현 가능!

### 힙의 응용
- 정렬(heapsort)
- 우선 순위 큐(priority queue) : 큐에 들어갈 때에는 순서 상관 없이 들어가고, 빠져나올 때 우선순위(여기선 스코빌 지수)에 따라 빠져나온다.

<br>
<br>

### Step 5-2: Python 풀이 예제 보기
```python
import heapq # 파이썬에서 힙을 이용하기 위한 라이브러리. q가 붙은 이유는 우선순위 큐를 이용하기 위해!
heap.heapify(L) # 리스트 L로부터 min heap 구성
m = heapq.heappop(L) # min heap L에서 최소값 삭제(반환)그리고 다시 힙의 구조를 유지한다.
heapq.heappush(L, x) # min heap L에 원소 x 삽입 그리고 다시 힙의 구조를 유지한다.
```
```python
import heapq
def solution(scoville, K):
    answer = 0
    heapq.heapify(scoville)
    while True:# 한번 도는데 최대 O(N)
        min1 = heapq.heappop(scoville) # 힙에서 가장 작은 수 팝. 가장 안매운 음식, O(logN)
        if min1 >= K:
            break
        elif len(scoville) == 0: # 다 섞어도 스코빌 지수를 넘지 못하면
            answer = -1
        min2 = heapq.heappop(scoville)# 두번째로 가장 안매운 음식, O(logN)
        new_scoville = min1+(min2*2)
        heapq.heappush(scoville, new_scoville) # 섞은 음식을 힙에 추가, O(logN)
        answer += 1
    return answer
```
복잡도는 O(NlogN)이다.<br>
리스트나 배열을 정렬해서 쓰게 되면 O(N^2)이 된다.<br>

<br>
<br>

### Step 5-3: 풀어서 내걸로 만들자! "더 맵게"
```python
import heapq
def solution(scoville, K):
    answer = 0
    heapq.heapify(scoville)# 힙을 만든다.
    
    while scoville[0] < K:# 배열의 모든 요소가 스코빌 기준치 이상일때까지 돌린다
        if len(scoville)==2:# 음식이 두개 남아있을때
            if heapq.heappop(scoville)+(heapq.heappop(scoville)*2) < K:
                return -1# 남은거 섞었는데도 스코빌 기준치 못넘으면 -1
            else:#남은거 섞어서 스코빌 기준치 넘으면 +1
                return answer+1
        elif len(scoville)<=1 and scoville[0]<K:#1개 이하로 남았는데 스코빌 기준치 못넘으면 -1
            return -1
        heapq.heappush(scoville, heapq.heappop(scoville)+(heapq.heappop(scoville)*2)) # 힙에 스코빌 지수가 가장 낮은 음식, 그다음으로 낮은 음식을 팝해서 연산해준 후 결과를 푸시해준다.
        answer += 1 # 연산 횟수를 증가시켜준다.
    # print(scoville)

    return answer
```