---
title : "[프로그래머스 코딩테스트]Level03 - N으로 표현"
data : 2020-12-04 00:15:28 -0400
categories : 코테
---
## Level03 - N으로 표현
### 문제 설명
아래와 같이 5와 사칙연산만으로 12를 표현할 수 있습니다.<br>
12 = 5 + 5 + (5 / 5) + (5 / 5)<br>
12 = 55 / 5 + 5 / 5<br>
12 = (55 + 5) / 5<br>
5를 사용한 횟수는 각각 6,5,4 입니다. 그리고 이중 가장 작은 경우는 4입니다.<br>
이처럼 숫자 N과 number가 주어질 때, N과 사칙연산만 사용해서 표현 할 수 있는 방법 중 N 사용횟수의 최솟값을 return 하도록 solution 함수를 작성하세요.<br>

### 제한사항
- N은 1 이상 9 이하입니다.
- number는 1 이상 32,000 이하입니다.
- 수식에는 괄호와 사칙연산만 가능하며 나누기 연산에서 나머지는 무시합니다.
- 최솟값이 8보다 크면 -1을 return 합니다.

### 입출력 예

|N|number|return|
|---|---|---|
|5|12|4|
|2|11|3|

```python
def solution(N, number):
    s = [set() for x in range(8)]# 몇번을 사용했을 때 만들어지는 수들을 다 담기 위한 리스트. 중복을 허용하지 않고 수를 모은다. [set()]*8하면 안된다!!
    # 왜 8인가? -> 문제에서 사칙연산 최대 8번까지만 가능하다고했음!
    for i, x in enumerate(s, start=1):
        # s에 들어있는 원소들을 x에 담고, i는 1부터 시작하는 연달은 정수를 가지게 한다.
        x.add(int(str(N)*i)) #한번사용:5, 두번사용:55,... 
    # print(s) # [{5}, {55}, {555}, {5555}, {55555}, {555555}, {5555555}, {55555555}] 여기에 이제 사칙연산하여 수들을 추가할 것이다.
    for i in range(len(s)):
        for j in range(i):
            for op1 in s[j]:#연산자의 앞에 놓일 수
                for op2 in s[i-j-1]:#연산자의 뒤에 놓일 수
                    # 사칙연산을 i+1번 사용했을 때 만들 수 있는 수들 계산하기
                    s[i].add(op1 + op2) 
                    s[i].add(op1 - op2)
                    s[i].add(op1 * op2)
                    if op2 != 0:
                        s[i].add(op1 // op2) # 나머지는 버려야 하므로 /이 아니라 //
        if number in s[i]:#넘버가 집합 안에 포함되어있으면
            answer = i + 1 #해당 넘버는 사칙연산을 i+1번만큼 사용해서 나올 수 있는 결과이다.
            break
        else: # 넘버를 집합에서 찾을 수 없으면 -1 반환
            answer = -1
    return answer

print(solution(5, 12)) # 4 
```